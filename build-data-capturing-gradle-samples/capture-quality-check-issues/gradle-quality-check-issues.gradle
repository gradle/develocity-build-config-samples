/**
 * This Gradle script captures issues found by reporting tasks,
 * and adds these as custom values.
 */

def buildScanApi = project.extensions.findByName('buildScan')
if (!buildScanApi) {
    return
}

def capture = new Capture(project.rootDir.path)

// configure reporting tasks
gradle.beforeProject { p ->

    p.pluginManager.withPlugin('groovy') {
        p.tasks.withType(org.gradle.api.plugins.quality.CodeNarc).configureEach {
            it.ignoreFailures = true
            it.reports.xml.required = true
            doLast {
                capture.processResults(buildScanApi, it.reports.xml.outputLocation, Capture.ReportType.CODENARC)
            }
        }
    }

    p.pluginManager.withPlugin('java') {
        p.tasks.withType(org.gradle.api.plugins.quality.Checkstyle).configureEach {
            it.ignoreFailures = true
            it.reports.xml.required = true
            doLast {
                capture.processResults(buildScanApi, it.reports.xml.outputLocation, Capture.ReportType.CHECKSTYLE)
            }
        }

        p.tasks.withType(com.github.spotbugs.snom.SpotBugsTask).configureEach {
            it.reports.create("xml")
            it.reports.getByName("xml").enabled = true
            it.ignoreFailures = true
            doLast {
                capture.processResults(buildScanApi, it.reports.xml.outputLocation, Capture.ReportType.SPOTBUGS)
            }
        }
    }
}

// Quality check service
class Capture {

    enum ReportType {
        CHECKSTYLE, CODENARC, FINDBUGS, SPOTBUGS
    }

    enum SpotBugsParent {
        BugInstance, Method, Class, Field
    }

    def projectRootDir

    Capture(def projectRootDir) {
        this.projectRootDir = projectRootDir
    }

    void processResults(def buildScanApi, def outputLocation, def reportType) {
        def reportFile = outputLocation.get().getAsFile()
        if (!reportFile.exists()) {
            return
        }

        def xmlReport = new XmlSlurper().parse(reportFile)
        def valueName = ''
        def errors = [] as List<String>

        switch(reportType) {
            case ReportType.CHECKSTYLE:
                valueName = 'Verification Checkstyle'
                errors = xmlReport.file.collect {
                    def filePath = it.@name.text().minus(projectRootDir)
                    it.error.collect { "${filePath}:${it.@line}:${it.@column} \u2192 ${it.@message}" }
                }.flatten() as List<String>
                break;
            case ReportType.CODENARC:
                valueName = 'Verification CodeNarc'
                errors = xmlReport.Package.collect {
                    def sourceDirectory = it.parent().Project.SourceDirectory.text()
                    sourceDirectory = (sourceDirectory.endsWith('/') ? sourceDirectory : sourceDirectory + '/')
                    it.File.collect {
                        def filePath = sourceDirectory + it.@name.text().minus(projectRootDir)
                        it.Violation.collect { "${filePath}:${it.@lineNumber} \u2192 ${it.Message.text()}" }
                    }.flatten()
                }.flatten() as List<String>
                break;
            case ReportType.SPOTBUGS:
            case ReportType.FINDBUGS:
                if(ReportType.FINDBUGS == reportType) {
                    valueName = 'Verification FindBugs'
                } else {
                    valueName = 'Verification SpotBugs'
                }
                errors = xmlReport.BugInstance.collect { bugInstance ->
                    def type = bugInstance.@type.text()
                    def error = bugInstance.breadthFirst().findAll { it.name() == 'SourceLine' }.sort(false) { it.parent().name() as SpotBugsParent }.first()
                    def startLine = error.@start.text()
                    def endLine = error.@end.text()
                    def lineNumber = endLine == startLine ? startLine : "$startLine-$endLine"
                    def sourcePathType = error.@sourcepath.text().subSequence(error.@sourcepath.text().lastIndexOf(".") + 1, error.@sourcepath.text().length())
                    def projectPath = bugInstance.parent().Project.SrcDir.find { it.text().endsWith(sourcePathType) }
                    def absolutePath = "$projectPath/${error.@sourcepath.text()}"
                    def relativePath = absolutePath.minus(projectRootDir)
                    "${relativePath}:${lineNumber} \u2192 ${type}"
                }.flatten() as List<String>
                break;
        }

        errors.each { buildScanApi.value "${valueName}", "${it}" }
    }
}
